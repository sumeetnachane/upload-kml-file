{"version":3,"file":"togeojson.umd.js","sources":["../lib/lib/shared.ts","../lib/lib/gpx/extensions.ts","../lib/lib/gpx/coord_pair.ts","../lib/lib/gpx/line.ts","../lib/lib/gpx/properties.ts","../lib/lib/gpx.ts","../lib/lib/tcx.ts","../lib/lib/kml/fixColor.ts","../lib/lib/kml/extractStyle.ts","../lib/lib/kml/geometry.ts","../lib/lib/kml/shared.ts","../lib/lib/kml/ground_overlay.ts","../lib/lib/kml/placemark.ts","../lib/lib/kml.ts"],"sourcesContent":["import type { Feature, Geometry } from \"geojson\";\n\nexport function $(element: Element | Document, tagName: string): Element[] {\n  return Array.from(element.getElementsByTagName(tagName));\n}\n\nexport type P = NonNullable<Feature[\"properties\"]>;\nexport type F = Feature<Geometry | null>;\n\nexport type StyleMap = { [key: string]: P };\n\nexport type NS = [string, string][];\n\nexport function normalizeId(id: string) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\n\nexport function $ns(\n  element: Element | Document,\n  tagName: string,\n  ns: string\n): Element[] {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n\n/**\n * get the content of a text node, if any\n */\nexport function nodeVal(node: Element | null) {\n  node?.normalize();\n  return node?.textContent || \"\";\n}\n\n/**\n * Get one Y child of X, if any, otherwise null\n */\nexport function get1(\n  node: Element,\n  tagName: string,\n  callback?: (elem: Element) => unknown\n) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\n\nexport function get(\n  node: Element | null,\n  tagName: string,\n  callback?: (elem: Element, properties: P) => P\n) {\n  const properties: Feature[\"properties\"] = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\n\nexport function val1(\n  node: Element,\n  tagName: string,\n  callback: (val: string) => P | undefined | void\n): P {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function $num(\n  node: Element,\n  tagName: string,\n  callback: (val: number) => Feature[\"properties\"]\n) {\n  const val = Number.parseFloat(nodeVal(get1(node, tagName)));\n  if (Number.isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function num1(\n  node: Element,\n  tagName: string,\n  callback?: (val: number) => unknown\n) {\n  const val = Number.parseFloat(nodeVal(get1(node, tagName)));\n  if (Number.isNaN(val)) return undefined;\n  if (callback) callback(val);\n  return val;\n}\n\nexport function getMulti(node: Element, propertyNames: string[]): P {\n  const properties: P = {};\n  for (const property of propertyNames) {\n    val1(node, property, (val) => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\n\nexport function isElement(node: Node | null): node is Element {\n  return node?.nodeType === 1;\n}\n","import { isElement, nodeVal } from \"../shared\";\n\nexport type ExtendedValues = [string, string | number][];\n\nexport function getExtensions(node: Element | null): ExtendedValues {\n  let values: [string, string | number][] = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\n\nfunction abbreviateName(name: string) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\n\nfunction parseNumeric(val: string) {\n  const num = Number.parseFloat(val);\n  return Number.isNaN(num) ? val : num;\n}\n","import type { Position } from \"geojson\";\nimport { get1, nodeVal, num1 } from \"../shared\";\nimport { type ExtendedValues, getExtensions } from \"./extensions\";\n\ninterface CoordPair {\n  coordinates: Position;\n  time: string | null;\n  extendedValues: ExtendedValues;\n}\n\nexport function coordPair(node: Element): CoordPair | null {\n  const ll = [\n    Number.parseFloat(node.getAttribute(\"lon\") || \"\"),\n    Number.parseFloat(node.getAttribute(\"lat\") || \"\"),\n  ];\n\n  if (Number.isNaN(ll[0]) || Number.isNaN(ll[1])) {\n    return null;\n  }\n\n  num1(node, \"ele\", (val) => {\n    ll.push(val);\n  });\n\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\")),\n  };\n}\n","import { $num, type P, get, val1 } from \"../shared\";\n\nexport function getLineStyle(node: Element | null) {\n  return get(node, \"line\", (lineStyle) => {\n    const val: P = Object.assign(\n      {},\n      val1(lineStyle, \"color\", (color) => {\n        return { stroke: `#${color}` };\n      }),\n      $num(lineStyle, \"opacity\", (opacity) => {\n        return { \"stroke-opacity\": opacity };\n      }),\n      $num(lineStyle, \"width\", (width) => {\n        // GPX width is in mm, convert to px with 96 px per inch\n        return { \"stroke-width\": (width * 96) / 25.4 };\n      })\n    );\n    return val;\n  });\n}\n","import { $, type NS, getMulti, nodeVal } from \"../shared\";\n\nexport function extractProperties(ns: NS, node: Element) {\n  const properties = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n\n  for (const [n, url] of ns) {\n    for (const child of Array.from(node.getElementsByTagNameNS(url, \"*\"))) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child)?.trim();\n    }\n  }\n\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map((link) =>\n      Object.assign(\n        { href: link.getAttribute(\"href\") },\n        getMulti(link, [\"text\", \"type\"])\n      )\n    );\n  }\n\n  return properties;\n}\n","import type { Document as XDocument } from \"@xmldom/xmldom\";\nimport type {\n  Feature,\n  FeatureCollection,\n  LineString,\n  MultiLineString,\n  Point,\n  Position,\n} from \"geojson\";\nimport { coordPair } from \"./gpx/coord_pair\";\nimport { getLineStyle } from \"./gpx/line\";\nimport { extractProperties } from \"./gpx/properties\";\nimport { $, type NS, type P, get1, getMulti } from \"./shared\";\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints(node: Element, pointname: \"trkpt\" | \"rtept\") {\n  const pts = $(node, pointname);\n  const line: Position[] = [];\n  const times = [];\n  const extendedValues: P = {};\n\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural =\n        name === \"heart\" ? name : `${name.replace(\"gpxtpx:\", \"\")}s`;\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n\n  if (line.length < 2) return; // Invalid line in GeoJSON\n\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(ns: NS, node: Element): Feature<LineString> | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      { _gpxType: \"rte\" },\n      extractProperties(ns, node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getTrack(\n  ns: NS,\n  node: Element\n): Feature<LineString | MultiLineString> | null {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (const segment of segments) {\n    const line = getPoints(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times?.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return null;\n\n  const multi = extractedLines.length > 1;\n\n  const properties: Feature[\"properties\"] = Object.assign(\n    { _gpxType: \"trk\" },\n    extractProperties(ns, node),\n    getLineStyle(get1(node, \"extensions\")),\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(ns: NS, node: Element): Feature<Point> | null {\n  const properties: Feature[\"properties\"] = Object.assign(\n    extractProperties(ns, node),\n    getMulti(node, [\"sym\"])\n  );\n  const pair = coordPair(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates,\n    },\n  };\n}\n\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* gpxGen(node: Document | XDocument): Generator<Feature> {\n  const n = node as Document;\n  const GPXX = \"gpxx\";\n  const GPXX_URI = \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\";\n  // Namespaces\n  const ns: NS = [[GPXX, GPXX_URI]];\n  const attrs = n.getElementsByTagName(\"gpx\")[0]?.attributes;\n  if (attrs) {\n    for (const attr of Array.from(attrs)) {\n      if (attr.name?.startsWith(\"xmlns:\") && attr.value !== GPXX_URI) {\n        ns.push([attr.name, attr.value]);\n      }\n    }\n  }\n\n  for (const track of $(n, \"trk\")) {\n    const feature = getTrack(ns, track);\n    if (feature) yield feature;\n  }\n\n  for (const route of $(n, \"rte\")) {\n    const feature = getRoute(ns, route);\n    if (feature) yield feature;\n  }\n\n  for (const waypoint of $(n, \"wpt\")) {\n    const point = getPoint(ns, waypoint);\n    if (point) yield point;\n  }\n}\n\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nexport function gpx(node: Document | XDocument): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node)),\n  };\n}\n","import type { Document as XDocument } from \"@xmldom/xmldom\";\nimport type { Feature, FeatureCollection, Position } from \"geojson\";\nimport { $, type P, get, get1, nodeVal, num1 } from \"./shared\";\n\ntype PropertyMapping = readonly [string, string][];\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES: PropertyMapping = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES: PropertyMapping = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction getProperties(node: Element, attributeNames: PropertyMapping) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = Number.parseFloat(nodeVal(elem));\n    if (!Number.isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(node: Element) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (\n    ll[0] === undefined ||\n    Number.isNaN(ll[0]) ||\n    ll[1] === undefined ||\n    Number.isNaN(ll[1])\n  ) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", (alt) => {\n    const a = Number.parseFloat(nodeVal(alt));\n    if (!Number.isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll as number[],\n    time: time || null,\n    heartRate: heartRate ? Number.parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node: Element) {\n  const pts = $(node, \"Trackpoint\");\n  const line: Position[] = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties: P = {};\n  const result = { extendedProperties };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const { time, heartRate, extensions } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node: Element): Feature | null {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line: any;\n  const properties: P = Object.assign(\n    Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)),\n    get(node, \"Name\", (nameElement) => {\n      return { name: nodeVal(nameElement) };\n    })\n  );\n\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n\n  if (track.length === 0) return null;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry:\n      track.length === 1\n        ? {\n            type: \"LineString\",\n            coordinates: track[0],\n          }\n        : {\n            type: \"MultiLineString\",\n            coordinates: track,\n          },\n  };\n}\n\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function* tcxGen(node: Document | XDocument): Generator<Feature> {\n  for (const lap of $(node as Document, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n\n  for (const course of $(node as Document, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function tcx(node: Document | XDocument): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node)),\n  };\n}\n","import type { P } from \"../shared\";\n\nexport function fixColor(v: string, prefix: string): P {\n  const properties: P = {};\n  const colorProp =\n    prefix === \"stroke\" || prefix === \"fill\" ? prefix : `${prefix}-color`;\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = `#${v}`;\n  } else if (v.length === 8) {\n    properties[`${prefix}-opacity`] =\n      Number.parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] =\n      `#${v.substring(6, 8)}${v.substring(4, 6)}${v.substring(2, 4)}`;\n  }\n  return properties;\n}\n","import { type P, get, nodeVal, num1, val1 } from \"../shared\";\nimport { fixColor } from \"./fixColor\";\n\nfunction numericProperty(node: Element, source: string, target: string): P {\n  const properties: P = {};\n  num1(node, source, (val) => {\n    properties[target] = val;\n  });\n  return properties;\n}\n\nfunction getColor(node: Element, output: string): P {\n  return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\n\nexport function extractIconHref(node: Element) {\n  return get(node, \"Icon\", (icon, properties) => {\n    val1(icon, \"href\", (href) => {\n      properties.icon = href;\n    });\n    return properties;\n  });\n}\n\nexport function extractIcon(node: Element) {\n  return get(node, \"IconStyle\", (iconStyle) => {\n    return Object.assign(\n      getColor(iconStyle, \"icon\"),\n      numericProperty(iconStyle, \"scale\", \"icon-scale\"),\n      numericProperty(iconStyle, \"heading\", \"icon-heading\"),\n      get(iconStyle, \"hotSpot\", (hotspot) => {\n        const left = Number.parseFloat(hotspot.getAttribute(\"x\") || \"\");\n        const top = Number.parseFloat(hotspot.getAttribute(\"y\") || \"\");\n        const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n        const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n        if (!Number.isNaN(left) && !Number.isNaN(top))\n          return {\n            \"icon-offset\": [left, top],\n            \"icon-offset-units\": [xunits, yunits],\n          };\n        return {};\n      }),\n      extractIconHref(iconStyle)\n    );\n  });\n}\n\nexport function extractLabel(node: Element) {\n  return get(node, \"LabelStyle\", (labelStyle) => {\n    return Object.assign(\n      getColor(labelStyle, \"label\"),\n      numericProperty(labelStyle, \"scale\", \"label-scale\")\n    );\n  });\n}\n\nexport function extractLine(node: Element) {\n  return get(node, \"LineStyle\", (lineStyle) => {\n    return Object.assign(\n      getColor(lineStyle, \"stroke\"),\n      numericProperty(lineStyle, \"width\", \"stroke-width\")\n    );\n  });\n}\n\nexport function extractPoly(node: Element) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(\n      properties,\n      get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")),\n      val1(polyStyle, \"fill\", (fill) => {\n        if (fill === \"0\") return { \"fill-opacity\": 0 };\n      }),\n      val1(polyStyle, \"outline\", (outline) => {\n        if (outline === \"0\") return { \"stroke-opacity\": 0 };\n      })\n    );\n  });\n}\n\nexport function extractStyle(node: Element) {\n  return Object.assign(\n    {},\n    extractPoly(node),\n    extractLine(node),\n    extractLabel(node),\n    extractIcon(node)\n  );\n}\n","import type { Geometry, LineString, Point, Position } from \"geojson\";\nimport { $, $ns, get1, isElement, nodeVal } from \"../shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n/**\n * Get one coordinate from a coordinate array, if any\n */\nexport function coord1(value: string): Position {\n  return value\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(Number.parseFloat)\n    .filter((num) => !Number.isNaN(num))\n    .slice(0, 3);\n}\n\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nexport function coord(value: string): Position[] {\n  return value\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1)\n    .filter((coord) => {\n      return coord.length >= 2;\n    });\n}\n\nfunction gxCoords(\n  node: Element\n): { geometry: Point | LineString; times: string[] } | null {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n\n  const coordinates = elems.map((elem) => {\n    return nodeVal(elem).split(\" \").map(Number.parseFloat);\n  });\n\n  if (coordinates.length === 0) {\n    return null;\n  }\n\n  return {\n    geometry:\n      coordinates.length > 2\n        ? {\n            type: \"LineString\",\n            coordinates,\n          }\n        : {\n            type: \"Point\",\n            coordinates: coordinates[0],\n          },\n    times: $(node, \"when\").map((elem) => nodeVal(elem)),\n  };\n}\n\nexport function fixRing(ring: Position[]) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\n\nexport function getCoordinates(node: Element) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\n\ninterface GeometriesAndTimes {\n  geometries: Geometry[];\n  coordTimes: string[][];\n}\n\nexport function getGeometry(node: Element): GeometriesAndTimes {\n  let geometries: Geometry[] = [];\n  let coordTimes: string[][] = [];\n\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes.item(i);\n    if (isElement(child)) {\n      switch (child.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\": {\n          const childGeometries = getGeometry(child);\n          geometries = geometries.concat(childGeometries.geometries);\n          coordTimes = coordTimes.concat(childGeometries.coordTimes);\n          break;\n        }\n\n        case \"Point\": {\n          const coordinates = coord1(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"Point\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"LinearRing\":\n        case \"LineString\": {\n          const coordinates = coord(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"LineString\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"Polygon\": {\n          const coords = [];\n          for (const linearRing of $(child, \"LinearRing\")) {\n            const ring = fixRing(coord(getCoordinates(linearRing)));\n            if (ring.length >= 4) {\n              coords.push(ring);\n            }\n          }\n          if (coords.length) {\n            geometries.push({\n              type: \"Polygon\",\n              coordinates: coords,\n            });\n          }\n          break;\n        }\n        case \"Track\":\n        case \"gx:Track\": {\n          const gx = gxCoords(child);\n          if (!gx) break;\n          const { times, geometry } = gx;\n          geometries.push(geometry);\n          if (times.length) coordTimes.push(times);\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    geometries,\n    coordTimes,\n  };\n}\n","import {\n  $,\n  type P,\n  type StyleMap,\n  get,\n  get1,\n  nodeVal,\n  normalizeId,\n  val1,\n} from \"../shared\";\n\nexport type TypeConverter = (x: string) => unknown;\nexport type Schema = { [key: string]: TypeConverter };\n\nconst toNumber: TypeConverter = (x) => Number(x);\nexport const typeConverters: Record<string, TypeConverter> = {\n  string: (x) => x,\n  int: toNumber,\n  uint: toNumber,\n  short: toNumber,\n  ushort: toNumber,\n  float: toNumber,\n  double: toNumber,\n  bool: (x) => Boolean(x),\n};\n\nexport function extractExtendedData(node: Element, schema: Schema) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(\n        get1(data, \"value\")\n      );\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      const name = simpleData.getAttribute(\"name\") || \"\";\n      const typeConverter = schema[name] || typeConverters.string;\n      properties[name] = typeConverter(nodeVal(simpleData));\n    }\n    return properties;\n  });\n}\n\nexport function getMaybeHTMLDescription(node: Element) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c as Element),\n        },\n      };\n    }\n  }\n  return {};\n}\n\nexport function extractTimeSpan(node: Element): P {\n  return get(node, \"TimeSpan\", (timeSpan) => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\")),\n      },\n    };\n  });\n}\n\nexport function extractTimeStamp(node: Element): P {\n  return get(node, \"TimeStamp\", (timeStamp) => {\n    return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n  });\n}\n\nexport function extractCascadedStyle(node: Element, styleMap: StyleMap): P {\n  return val1(node, \"styleUrl\", (styleUrl) => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({ styleUrl }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return { styleUrl };\n  });\n}\n","import type { Feature, Polygon } from \"geojson\";\nimport type { KMLOptions } from \"lib/kml\";\nimport { type StyleMap, get1, getMulti, num1 } from \"../shared\";\nimport { extractIconHref, extractStyle } from \"./extractStyle\";\nimport { coord, fixRing, getCoordinates } from \"./geometry\";\nimport {\n  type Schema,\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n} from \"./shared\";\n\ninterface BoxGeometry {\n  bbox?: BBox;\n  geometry: Polygon;\n}\n\nfunction getGroundOverlayBox(node: Element): BoxGeometry | null {\n  const latLonQuad = get1(node, \"gx:LatLonQuad\");\n\n  if (latLonQuad) {\n    const ring = fixRing(coord(getCoordinates(node)));\n    return {\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [ring],\n      },\n    };\n  }\n\n  return getLatLonBox(node);\n}\n\ntype BBox = [number, number, number, number];\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction rotateBox(\n  bbox: BBox,\n  coordinates: Polygon[\"coordinates\"],\n  rotation: number\n): Polygon[\"coordinates\"] {\n  const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n\n  return [\n    coordinates[0].map((coordinate) => {\n      const dy = coordinate[1] - center[1];\n      const dx = coordinate[0] - center[0];\n      const distance = Math.sqrt(dy ** 2 + dx ** 2);\n      const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n\n      return [\n        center[0] + Math.cos(angle) * distance,\n        center[1] + Math.sin(angle) * distance,\n      ];\n    }),\n  ];\n}\n\nfunction getLatLonBox(node: Element): BoxGeometry | null {\n  const latLonBox = get1(node, \"LatLonBox\");\n\n  if (latLonBox) {\n    const north = num1(latLonBox, \"north\");\n    const west = num1(latLonBox, \"west\");\n    const east = num1(latLonBox, \"east\");\n    const south = num1(latLonBox, \"south\");\n    const rotation = num1(latLonBox, \"rotation\");\n\n    if (\n      typeof north === \"number\" &&\n      typeof south === \"number\" &&\n      typeof west === \"number\" &&\n      typeof east === \"number\"\n    ) {\n      const bbox: BBox = [west, south, east, north];\n      let coordinates = [\n        [\n          [west, north], // top left\n          [east, north], // top right\n          [east, south], // top right\n          [west, south], // bottom left\n          [west, north], // top left (again)\n        ],\n      ];\n      if (typeof rotation === \"number\") {\n        coordinates = rotateBox(bbox, coordinates, rotation);\n      }\n      return {\n        bbox,\n        geometry: {\n          type: \"Polygon\",\n          coordinates,\n        },\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getGroundOverlay(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Polygon | null> | null {\n  const box = getGroundOverlayBox(node);\n\n  const geometry = box?.geometry || null;\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Polygon | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      /**\n       * Related to\n       * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n       */\n      { \"@geometry-type\": \"groundoverlay\" },\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractIconHref(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node)\n    ),\n  };\n\n  if (box?.bbox) {\n    feature.bbox = box.bbox;\n  }\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import type { Feature, Geometry } from \"geojson\";\nimport type { KMLOptions } from \"lib/kml\";\nimport { type StyleMap, getMulti } from \"../shared\";\nimport { extractStyle } from \"./extractStyle\";\nimport { getGeometry } from \"./geometry\";\nimport {\n  type Schema,\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n} from \"./shared\";\n\nfunction geometryListToGeometry(geometries: Geometry[]): Geometry | null {\n  return geometries.length === 0\n    ? null\n    : geometries.length === 1\n      ? geometries[0]\n      : {\n          type: \"GeometryCollection\",\n          geometries,\n        };\n}\n\nexport function getPlacemark(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Geometry | null> | null {\n  const { coordTimes, geometries } = getGeometry(node);\n\n  const geometry = geometryListToGeometry(geometries);\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Geometry | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node),\n      coordTimes.length\n        ? {\n            coordinateProperties: {\n              times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n            },\n          }\n        : {}\n    ),\n  };\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import type { Document as XDocument } from \"@xmldom/xmldom\";\nimport type { FeatureCollection, Geometry } from \"geojson\";\nimport { extractStyle } from \"./kml/extractStyle\";\nimport { getGroundOverlay } from \"./kml/ground_overlay\";\nimport { getPlacemark } from \"./kml/placemark\";\nimport { type Schema, typeConverters } from \"./kml/shared\";\nimport {\n  $,\n  type F,\n  type P,\n  type StyleMap,\n  isElement,\n  nodeVal,\n  normalizeId,\n  val1,\n} from \"./shared\";\n\n/**\n * Options to customize KML output.\n *\n * The only option currently\n * is `skipNullGeometry`. Both the KML and GeoJSON formats support\n * the idea of features that don't have geometries: in KML,\n * this is a Placemark without a Point, etc element, and in GeoJSON\n * it's a geometry member with a value of `null`.\n *\n * toGeoJSON, by default, translates null geometries in KML to\n * null geometries in GeoJSON. For systems that use GeoJSON but\n * don't support null geometries, you can specify `skipNullGeometry`\n * to omit these features entirely and only include\n * features that have a geometry defined.\n */\nexport interface KMLOptions {\n  skipNullGeometry?: boolean;\n}\n\n/**\n * A folder including metadata. Folders\n * may contain other folders or features,\n * or nothing at all.\n */\nexport interface Folder {\n  type: \"folder\";\n  /**\n   * Standard values:\n   *\n   * * \"name\",\n   * * \"visibility\",\n   * * \"open\",\n   * * \"address\",\n   * * \"description\",\n   * * \"phoneNumber\",\n   * * \"visibility\",\n   */\n  meta: {\n    [key: string]: unknown;\n  };\n  children: Array<Folder | F>;\n}\n\n/**\n * A nested folder structure, represented\n * as a tree with folders and features.\n */\nexport interface Root {\n  type: \"root\";\n  children: Array<Folder | F>;\n}\n\ntype TreeContainer = Root | Folder;\n\nfunction getStyleId(style: Element) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (\n    !id &&\n    isElement(parentNode) &&\n    parentNode.localName === \"CascadingStyle\"\n  ) {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\n\nfunction buildStyleMap(node: Document): StyleMap {\n  const styleMap: StyleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", (styleUrl) => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\n\nfunction buildSchema(node: Document): Schema {\n  const schema: Schema = {};\n  for (const field of $(node, \"SimpleField\")) {\n    schema[field.getAttribute(\"name\") || \"\"] =\n      typeConverters[field.getAttribute(\"type\") || \"\"] || typeConverters.string;\n  }\n  return schema;\n}\n\nconst FOLDER_PROPS = [\n  \"name\",\n  \"visibility\",\n  \"open\",\n  \"address\",\n  \"description\",\n  \"phoneNumber\",\n  \"visibility\",\n] as const;\n\nfunction getFolder(node: Element): Folder {\n  const meta: P = {};\n\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName as any)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n\n  return {\n    type: \"folder\",\n    meta,\n    children: [],\n  };\n}\n\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nexport function kmlWithFolders(\n  node: Document | XDocument,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Root {\n  const n = node as Document;\n  const styleMap = buildStyleMap(n);\n  const schema = buildSchema(n);\n\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = [];\n  const tree: Root = { type: \"root\", children: [] };\n\n  function traverse(\n    node: Document | ChildNode | Element,\n    pointer: TreeContainer,\n    options: KMLOptions\n  ) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"GroundOverlay\": {\n          placemarks.push(node);\n          const placemark = getGroundOverlay(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Placemark\": {\n          placemarks.push(node);\n          const placemark = getPlacemark(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Folder\": {\n          const folder = getFolder(node);\n          pointer.children.push(folder);\n          pointer = folder;\n          break;\n        }\n      }\n    }\n\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer, options);\n      }\n    }\n  }\n\n  traverse(n, tree, options);\n\n  return tree;\n}\n\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* kmlGen(\n  node: Document | XDocument,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Generator<F> {\n  const n = node as Document;\n  const styleMap = buildStyleMap(n);\n  const schema = buildSchema(n);\n  for (const placemark of $(n, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n  for (const groundOverlay of $(n, \"GroundOverlay\")) {\n    const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nexport function kml(\n  node: Document | XDocument,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): FeatureCollection<Geometry | null> {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node as Document, options)),\n  };\n}\n"],"names":["$","element","tagName","Array","from","getElementsByTagName","normalizeId","id","nodeVal","node","normalize","textContent","get1","callback","n","result","length","get","properties","val1","val","$num","Number","parseFloat","isNaN","num1","getMulti","propertyNames","property","isElement","nodeType","getExtensions","values","child","childNodes","name","abbreviateName","nodeName","concat","push","parseNumeric","includes","num","coordPair","ll","getAttribute","time","coordinates","extendedValues","getLineStyle","lineStyle","Object","assign","color","stroke","opacity","width","extractProperties","ns","url","getElementsByTagNameNS","replace","trim","links","map","link","href","getPoints","pointname","pts","line","times","i","c","plural","fill","getRoute","type","_gpxType","geometry","getTrack","segments","track","extractedLines","segment","multi","coordinateProperties","props","entries","getPoint","pair","gpxGen","GPXX_URI","attrs","attributes","attr","startsWith","value","feature","route","waypoint","point","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","getProperties","attributeNames","tag","alias","elem","elements","undefined","heartRate","alt","a","extensions","heartRates","extendedProperties","getLap","allExtendedProperties","fromEntries","nameElement","heart","tcxGen","lap","course","fixColor","v","prefix","colorProp","substring","parseInt","numericProperty","source","target","getColor","output","extractIconHref","icon","extractStyle","polyStyle","outline","extractPoly","extractLine","labelStyle","extractLabel","iconStyle","hotspot","left","top","xunits","yunits","extractIcon","removeSpace","trimSpace","splitSpace","coord1","split","filter","slice","coord","gxCoords","elems","fixRing","ring","first","last","equal","Math","max","getCoordinates","getGeometry","geometries","coordTimes","item","childGeometries","coords","linearRing","gx","toNumber","x","typeConverters","string","int","uint","short","ushort","float","double","bool","Boolean","extractExtendedData","schema","extendedData","data","simpleData","typeConverter","getMaybeHTMLDescription","descriptionNode","description","extractTimeSpan","timeSpan","timespan","begin","end","extractTimeStamp","timeStamp","timestamp","extractCascadedStyle","styleMap","styleUrl","getGroundOverlayBox","latLonBox","north","west","east","south","rotation","bbox","center","coordinate","dy","dx","distance","sqrt","angle","atan2","DEGREES_TO_RADIANS","cos","sin","rotateBox","getLatLonBox","PI","getGroundOverlay","options","box","skipNullGeometry","visibility","getPlacemark","geometryListToGeometry","getStyleId","style","parentNode","localName","buildStyleMap","buildSchema","field","FOLDER_PROPS","kmlGen","placemark","groundOverlay","features","tree","children","traverse","pointer","folder","meta","getFolder"],"mappings":"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"}